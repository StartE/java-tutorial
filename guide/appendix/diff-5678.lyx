#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass ctex-book
\begin_preamble
\input{../preamble.tex}
\end_preamble
\use_default_options true
\begin_modules
logicalmkup
coderemarks
tip-inset
note-inset
warning-inset
theorems-bytype
theorems-chap-bytype
\end_modules
\maintain_unincluded_children false
\language chinese-simplified
\language_package default
\inputencoding utf8-plain
\fontencoding global
\font_roman "default" "DejaVu Sans"
\font_sans "default" "DejaVu Serif"
\font_typewriter "default" "DejaVu Sans Mono"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format pdf4
\output_sync 0
\bibtex_command default
\index_command default
\float_placement tbph
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 3
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\boxbgcolor #dad3d7
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
JDK 1.5、1.6、1.7、1.8的差别
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
对于初学者而言，这部分内容也许意义不大，可以舍弃？
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
参考：https://www.yidianzixun.com/article/0FCJpTC3?s=4&appid=xiaomi&ver=3.8.0&utk=0le7o
cax，需要进一步整理
\end_layout

\end_inset


\end_layout

\begin_layout Standard
对于很多刚接触java语言的初学者来说，要了解一门语言，最好的方式就是要能从基础的版本进行了解，升级的过程，以及升级的新特性，这样才能循序渐进的学好一门语言。今
天先为大家介绍一下JDK1.5版本到JDK1.7版本的特性。希望能给予帮助。
\end_layout

\begin_layout Standard
JDK1.5新特性： 1.自动装箱与拆箱：
\end_layout

\begin_layout Standard
自动装箱的过程：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中。
\end_layout

\begin_layout Standard
自动拆箱的过程：每当需要一个值时，被装箱对象中的值就被自动地提取出来，没必要再去调用intValue和doubleValue方法。
\end_layout

\begin_layout Standard
自动装箱，只需将该值赋给一个类型包装器引用，java会自动创建一个对象。
\end_layout

\begin_layout Standard
自动拆箱，只需将该对象值赋给一个基本类型即可。
\end_layout

\begin_layout Standard
java——类的包装器
\end_layout

\begin_layout Standard
类型包装器有：Double,Float,Long,Integer,Short,Character和Boolean
\end_layout

\begin_layout Standard
2.枚举
\end_layout

\begin_layout Standard
把集合里的对象元素一个一个提取出来。枚举类型使代码更具可读性，理解清晰，易于维护。枚举类型是强类型的，从而保证了系统安全性。而以类的静态字段实现的类似替代模型，
不具有枚举的简单性和类型安全性。
\end_layout

\begin_layout Standard
简单的用法：JavaEnum简单的用法一般用于代表一组常用常量，可用来代表一类相同类型的常量值。
\end_layout

\begin_layout Standard
复杂用法：Java为枚举类型提供了一些内置的方法，同事枚举常量还可以有自己的方法。可以很方便的遍历枚举对象。
\end_layout

\begin_layout Standard
3.静态导入
\end_layout

\begin_layout Standard
通过使用 import static，就可以不用指定 Constants 类名而直接使用静态成员，包括静态方法。
\end_layout

\begin_layout Standard
import xxxx 和 import static xxxx的区别是前者一般导入的是类文件如import java.util.Scanner;后者一般是导入静态
的方法，import static java.lang.System.out。
\end_layout

\begin_layout Standard
4.可变参数（Varargs）
\end_layout

\begin_layout Standard
可变参数的简单语法格式为：
\end_layout

\begin_layout Standard
methodName([argumentList], dataType...argumentName);
\end_layout

\begin_layout Standard
5.内省（Introspector）
\end_layout

\begin_layout Standard
是 Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性name,那我们可以通过getName,setName来得到其值或者设置新
 的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter /setter方法，通
过这些API可以使你不需要了解这个规则（但你最好还是要搞清楚），这些API存放于包java.beans中。
\end_layout

\begin_layout Standard
一 般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器 （PropertyDescript
or），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来 调用这些方法。
\end_layout

\begin_layout Standard
6.泛型(Generic)
\end_layout

\begin_layout Standard
C++ 通过模板技术可以指定集合的元素类型，而Java在1.5之前一直没有相对应的功能。一个集合可以放任何类型的对象，相应地从集合里面拿对象的时候我们也
 不得不对他们进行强制得类型转换。猛虎引入了泛型，它允许指定集合里元素的类型，这样你可以得到强类型在编译时刻进行类型检查的好处。
\end_layout

\begin_layout Standard
7.For-Each循环
\end_layout

\begin_layout Standard
For-Each循环得加入简化了集合的遍历。假设我们要遍历一个集合对其中的元素进行一些处理。
\end_layout

\begin_layout Standard
JDK 1.6新特性
\end_layout

\begin_layout Standard
有关JDK1.6的新特性reamerit的博客文章已经说的很详细了。
\end_layout

\begin_layout Standard
1.Desktop类和SystemTray类
\end_layout

\begin_layout Standard
在JDK6中 ,AWT新增加了两个类:Desktop和SystemTray。
\end_layout

\begin_layout Standard
前者可以用来打开系统默认浏览器浏览指定的URL,打开系统默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件
),用系统默认的打印机打印文档;后者可以用来在系统托盘区创建一个托盘程序.
\end_layout

\begin_layout Standard
2.使用JAXB2来实现对象与XML之间的映射
\end_layout

\begin_layout Standard
JAXB是Java Architecture for XML Binding的缩写，可以将一个Java对象转变成为XML格式，反之亦然。
\end_layout

\begin_layout Standard
我 们把对象与关系数据库之间的映射称为ORM, 其实也可以把对象与XML之间的映射称为OXM(Object XML Mapping).
 原来JAXB是Java EE的一部分，在JDK6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。JDK6中自带的这个JAXB版本是2.0,
 比起1.0(JSR 31)来，JAXB2(JSR 222)用JDK5的新特性Annotation来标识要作绑定的类和属性等，这就极大简化了开发的工作量。
\end_layout

\begin_layout Standard
实 际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外,JAXB2在底层是用StAX(JSR
 173)来处理XML文档。除了JAXB之外，我们还可以通过XMLBeans和Castor等来实现同样的功能。
\end_layout

\begin_layout Standard
3.理解StAX
\end_layout

\begin_layout Standard
StAX(JSR 173)是JDK6.0中除了DOM和SAX之外的又一种处理XML文档的API。
\end_layout

\begin_layout Standard
StAX 的来历 ：在JAXP1.3(JSR 206)有两种处理XML文档的方法:DOM(Document Object Model)和SAX(Simple
 API for XML).
\end_layout

\begin_layout Standard
由 于JDK6.0中的JAXB2(JSR 222)和JAX-WS 2.0(JSR 224)都会用到StAX所以Sun决定把StAX加入到JAXP家族当中来，并将JA
XP的版本升级到1.4(JAXP1.4是JAXP1.3的维护版 本).
 JDK6里面JAXP的版本就是1.4.
 。
\end_layout

\begin_layout Standard
StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件
迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使
解析器产生一个解析事件 然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；
\end_layout

\begin_layout Standard
SAX也是基于事件处理xml文档，但却 是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xm
l文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。
\end_layout

\begin_layout Standard
4.使用Compiler API
\end_layout

\begin_layout Standard
现在我 们可以用JDK6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java
代码并编译执行这些代码，有点动态语言的特征。
\end_layout

\begin_layout Standard
这 个特性对于某些需要用到动态编译的应用程序相当有用， 比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到
效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件，当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP
 Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去
 做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译,而且是跨平台的。
\end_layout

\begin_layout Standard
5.轻量级Http Server API
\end_layout

\begin_layout Standard
JDK6 提供了一个简单的Http Server API,据此我们可以构建自己的嵌入式Http Server,它支持Http和Https协议,提供了HTTP1.1
的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现,程序员必须自己实现HttpHandler接口,HttpServer会调用H
ttpHandler实现类的回调方法来处理客户端请求,在 这里,我们把一个Http请求和它的响应称为一个交换,包装成HttpExchange类,HttpServ
er负责将HttpExchange传给 HttpHandler实现类的回调方法.
\end_layout

\begin_layout Standard
6.插入式注解处理API(Pluggable Annotation Processing API)
\end_layout

\begin_layout Standard
插入式注解处理API(JSR 269)提供一套标准API来处理Annotations(JSR 175)
\end_layout

\begin_layout Standard
实 际上JSR 269不仅仅用来处理Annotation,我觉得更强大的功能是它建立了Java 语言本身的一个模型,它把method, package,
 constructor, type, variable, enum, annotation等Java语言元素映射为Types和Elements(两者有什么区别
?), 从而将Java语言的语义映射成为对象, 我们可以在javax.lang.model包下面可以看到这些类.
 所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境.
\end_layout

\begin_layout Standard
JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器
的一个插件,所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码,编译器
会再调用一次Annotation Processor,如果第二次处理还有新代码产生,就会接着调用Annotation Processor,直到没有新代码产生为止.
每执行一次process方法被称为一个"round",这样整个Annotation processing过程可以看作是一个round的序列.
\end_layout

\begin_layout Standard
JSR 269主要被设计成为针对Tools或者容器的API.
 举个例子,我们想建立一套基于Annotation的单元测试框架(如TestNG),在测试类里面用Annotation来标识测试期间需要执行的测试方法。
\end_layout

\begin_layout Standard
7.用Console开发控制台程序
\end_layout

\begin_layout Standard
JDK6 中提供了java.io.Console 类专用来访问基于字符的控制台设备.
 你的程序如果要与Windows下的cmd或者Linux下的Terminal交互,就可以用Console类代劳.
 但我们不总是能得到可用的Console, 一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用.
 如果JVM是在交互式命令行(比如Windows的cmd)中启动的,并且输入输出没有重定向到另外的地方,那么就可以得到一个可用的Console实
 例.
\end_layout

\begin_layout Standard
8.对脚本语言的支持如: ruby, groovy, javascript.
\end_layout

\begin_layout Standard
9.Common Annotations
\end_layout

\begin_layout Standard
Common annotations原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中.
\end_layout

\begin_layout Standard
随 着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB,Web Services)都会用Annot
ation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务）, 如果这些技术为通用目的都单独定义了自己的Annotations,显
然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java
 EE 各种技术的一致性.
\end_layout

\begin_layout Standard
下面列举出Common Annotations 1.0里面的10个Annotations Common Annotations
\end_layout

\begin_layout Standard
Annotation Retention Target Description
\end_layout

\begin_layout Standard
Generated Source ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD,
 PACKAGE, PARAMETER, TYPE 用于标注生成的源代码
\end_layout

\begin_layout Standard
Resource Runtime TYPE, METHOD, FIELD 用于标注所依赖的资源,容器据此注入外部资源依赖，有基于字段的注入和基于setter方法
的注入两种方式
\end_layout

\begin_layout Standard
Resources Runtime TYPE 同时标注多个外部依赖，容器会把所有这些外部依赖注入
\end_layout

\begin_layout Standard
PostConstruct Runtime METHOD 标注当容器注入所有依赖之后运行的方法，用来进行依赖注入后的初始化工作，只有一个方法可以标注为PostC
onstruct
\end_layout

\begin_layout Standard
PreDestroy Runtime METHOD 当对象实例将要被从容器当中删掉之前，要执行的回调方法要标注为PreDestroy RunAs
 Runtime TYPE 用于标注用什么安全角色来执行被标注类的方法，这个安全角色必须和Container 的Security角色一致的。RolesAllow
ed Runtime TYPE, METHOD 用于标注允许执行被标注类或方法的安全角色，这个安全角色必须和Container 的Security角色一致的
\end_layout

\begin_layout Standard
PermitAll Runtime TYPE, METHOD 允许所有角色执行被标注的类或方法
\end_layout

\begin_layout Standard
DenyAll Runtime TYPE, METHOD 不允许任何角色执行被标注的类或方法，表明该类或方法不能在Java EE容器里面运行
\end_layout

\begin_layout Standard
DeclareRoles Runtime TYPE 用来定义可以被应用程序检验的安全角色，通常用isUserInRole来检验安全角色
\end_layout

\begin_layout Standard
注意:
\end_layout

\begin_layout Standard
1.RolesAllowed,PermitAll,DenyAll不能同时应用到一个类或方法上
\end_layout

\begin_layout Standard
2.标注在方法上的RolesAllowed,PermitAll,DenyAll会覆盖标注在类上的RolesAllowed,PermitAll,DenyAll
\end_layout

\begin_layout Standard
3.RunAs,RolesAllowed,PermitAll,DenyAll和DeclareRoles还没有加到Java SE 6.0上来
\end_layout

\begin_layout Standard
4.
 处理以上Annotations的工作是由Java EE容器来做, Java SE 6.0只是包含了上面表格的前五种Annotations的定义类,并没有包含处理
这些Annotations的引擎,这个工作可以由Pluggable Annotation Processing API(JSR 269)来做
\end_layout

\begin_layout Standard
改动的地方最大的就是java GUI界面的显示了，JDK6.0（也就是JDK1.6）支持最新的windows vista系统的Windows Aero视窗效果，而J
DK1.5不支持！！！
\end_layout

\begin_layout Standard
你要在vista环境下编程的话最好装jdk6.0，否则它总是换到windows basic视窗效果.
\end_layout

\begin_layout Standard
JDK 1.7 新特性
\end_layout

\begin_layout Standard
1，switch中可以使用字串了
\end_layout

\begin_layout Standard
String s = "test";
\end_layout

\begin_layout Standard
switch (s) {
\end_layout

\begin_layout Standard
case "test" :
\end_layout

\begin_layout Standard
System.out.println("test");
\end_layout

\begin_layout Standard
case "test1" :
\end_layout

\begin_layout Standard
System.out.println("test1");
\end_layout

\begin_layout Standard
break ;
\end_layout

\begin_layout Standard
default :
\end_layout

\begin_layout Standard
System.out.println("break");
\end_layout

\begin_layout Standard
break ;
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
2，"<>"这个玩意儿的运用ListtempList = new ArrayList<>; 即泛型实例化类型自动推断。; // JDK 7 supports
 limited type inference for generic instance creation Listlst2 = new ArrayList<>
; lst1.add("Mon"); lst1.add("Tue"); lst2.add("Wed"); lst2.add("Thu"); for (String
 item: lst1) { System.out.println(item); } for (String item: lst2) { System.out.prin
tln(item); } } }
\end_layout

\begin_layout Standard
3.
 自定义自动关闭类
\end_layout

\begin_layout Standard
以下是jdk7 api中的接口，（不过注释太长，删掉了close方法的一部分注释）
\end_layout

\begin_layout Standard
/** * A resource that must be closed when it is no longer needed.
 * * @author Josh Bloch * @since 1.7 */publicinterface AutoCloseable { /**
 * Closes this resource, relinquishing any underlying resources.
 * This method is invoked automatically on objects managed by the * {@code
 try}-with-resources statement.
 * */void close throws Exception; }
\end_layout

\begin_layout Standard
只要实现该接口，在该类对象销毁时自动调用close方法，你可以在close方法关闭你想关闭的资源，例子如下
\end_layout

\begin_layout Standard
class TryClose implements AutoCloseable { @Override publicvoid close throw
 Exception { System.out.println(" Custom close method … close resources ");
 } }
\end_layout

\begin_layout Standard
//请看jdk自带类BufferedReader如何实现close方法（当然还有很多类似类型的类）
\end_layout

\begin_layout Standard
public void close throws IOException {
\end_layout

\begin_layout Standard
synchronized (lock) {
\end_layout

\begin_layout Standard
if (in == null)
\end_layout

\begin_layout Standard
return;
\end_layout

\begin_layout Standard
in.close;
\end_layout

\begin_layout Standard
in = null;
\end_layout

\begin_layout Standard
cb = null;
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
4.
 新增一些取环境信息的工具方法
\end_layout

\begin_layout Standard
File System.getJavaIoTempDir // IO临时文件夹
\end_layout

\begin_layout Standard
File System.getJavaHomeDir // JRE的安装目录
\end_layout

\begin_layout Standard
File System.getUserHomeDir // 当前用户目录
\end_layout

\begin_layout Standard
File System.getUserDir // 启动java进程时所在的目录
\end_layout

\begin_layout Standard
.......
\end_layout

\begin_layout Standard
5.
 Boolean类型反转，空指针安全,参与位运算
\end_layout

\begin_layout Standard
Boolean Booleans.negate(Boolean booleanObj)
\end_layout

\begin_layout Standard
True => False , False => True, Null => Null
\end_layout

\begin_layout Standard
boolean Booleans.and(boolean array)
\end_layout

\begin_layout Standard
boolean Booleans.or(boolean array)
\end_layout

\begin_layout Standard
boolean Booleans.xor(boolean array)
\end_layout

\begin_layout Standard
boolean Booleans.and(Boolean array)
\end_layout

\begin_layout Standard
boolean Booleans.or(Boolean array)
\end_layout

\begin_layout Standard
boolean Booleans.xor(Boolean array)
\end_layout

\begin_layout Standard
6.
 两个char间的equals
\end_layout

\begin_layout Standard
boolean Character.equalsIgnoreCase(char ch1, char ch2)
\end_layout

\begin_layout Standard
7，安全的加减乘除
\end_layout

\begin_layout Standard
int Math.safeToInt(long value)
\end_layout

\begin_layout Standard
int Math.safeNegate(int value)
\end_layout

\begin_layout Standard
long Math.safeSubtract(long value1, int value2)
\end_layout

\begin_layout Standard
long Math.safeSubtract(long value1, long value2)
\end_layout

\begin_layout Standard
int Math.safeMultiply(int value1, int value2)
\end_layout

\begin_layout Standard
long Math.safeMultiply(long value1, int value2)
\end_layout

\begin_layout Standard
long Math.safeMultiply(long value1, long value2)
\end_layout

\begin_layout Standard
long Math.safeNegate(long value)
\end_layout

\begin_layout Standard
int Math.safeAdd(int value1, int value2)
\end_layout

\begin_layout Standard
long Math.safeAdd(long value1, int value2)
\end_layout

\begin_layout Standard
long Math.safeAdd(long value1, long value2)
\end_layout

\begin_layout Standard
int Math.safeSubtract(int value1, int value2)
\end_layout

\begin_layout Standard
1.对Java集合（Collections）的增强支持
\end_layout

\begin_layout Standard
在JDK1.7之前的版本中，Java集合容器中存取元素的形式如下：
\end_layout

\begin_layout Standard
以List、Set、Map集合容器为例：
\end_layout

\begin_layout Standard
//创建List接口对象
\end_layout

\begin_layout Standard
list=new ArrayList;
\end_layout

\begin_layout Standard
list.add("item"); //用add方法获取对象
\end_layout

\begin_layout Standard
String Item=list.get(0); //用get方法获取对象
\end_layout

\begin_layout Standard
//创建Set接口对象
\end_layout

\begin_layout Standard
set=new HashSet;
\end_layout

\begin_layout Standard
set.add("item"); //用add方法添加对象
\end_layout

\begin_layout Standard
//创建Map接口对象
\end_layout

\begin_layout Standard
map=new HashMap;
\end_layout

\begin_layout Standard
map.put("key",1); //用put方法添加对象
\end_layout

\begin_layout Standard
int value=map.get("key");
\end_layout

\begin_layout Standard
在JDK1.7中，摒弃了Java集合接口的实现类，如：ArrayList、HashSet和HashMap。而是直接采用、{}的形式存入对象，采用的形式按照索引、键
值来获取集合中的对象，如下：
\end_layout

\begin_layout Standard
list=["item"]; //向List集合中添加元素
\end_layout

\begin_layout Standard
String item=list[0]; //从List集合中获取元素
\end_layout

\begin_layout Standard
set={"item"}; //向Set集合对象中添加元素
\end_layout

\begin_layout Standard
Map
\end_layout

\begin_layout Standard
int value=map["key"]; //从Map集合中获取对象
\end_layout

\begin_layout Standard
2.在Switch中可用String
\end_layout

\begin_layout Standard
在之前的版本中是不支持在Switch语句块中用String类型的数据的，这个功能在C#语言中早已被支持，好在JDK1.7中加入了。
\end_layout

\begin_layout Standard
String s = "test";
\end_layout

\begin_layout Standard
switch (s) {
\end_layout

\begin_layout Standard
case "test" :
\end_layout

\begin_layout Standard
System.out.println("test");
\end_layout

\begin_layout Standard
case "test1" :
\end_layout

\begin_layout Standard
System.out.println("test1");
\end_layout

\begin_layout Standard
break ;
\end_layout

\begin_layout Standard
default :
\end_layout

\begin_layout Standard
System.out.println("break");
\end_layout

\begin_layout Standard
break ;
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
3.数值可加下划线
\end_layout

\begin_layout Standard
例如：int one_million = 1_000_000;
\end_layout

\begin_layout Standard
4.支持二进制文字
\end_layout

\begin_layout Standard
例如：int binary = 0b1001_1001;
\end_layout

\begin_layout Standard
5.简化了可变参数方法的调用
\end_layout

\begin_layout Standard
当程序员试图使用一个不可具体化的可变参数并调用一个*varargs* （可变）方法时，编辑器会生成一个“非安全操作”的警告。
\end_layout

\begin_layout Standard
6、在try catch异常扑捉中，一个catch可以写多个异常类型，用"|"隔开，
\end_layout

\begin_layout Standard
jdk7之前：
\end_layout

\begin_layout Standard
try { ......
 } catch(ClassNotFoundException ex) { ex.printStackTrace; } catch(SQLException
 ex) { ex.printStackTrace; }
\end_layout

\begin_layout Standard
jdk7例子如下
\end_layout

\begin_layout Standard
try { ......
 } catch(ClassNotFoundException|SQLException ex) { ex.printStackTrace; }
\end_layout

\begin_layout Standard
7、jdk7之前，你必须用try{}finally{}在try内使用资源，在finally中关闭资源，不管try中的代码是否正常退出或者异常退出。jdk7之后，
你可以不必要写finally语句来关闭资源，只要你在try的括号内部定义要使用的资源。请看例子：
\end_layout

\begin_layout Standard
jdk7之前
\end_layout

\begin_layout Standard
import java.io.*; // Copy from one file to another file character by character.
 // Pre-JDK 7 requires you to close the resources using a finally block.publiccla
ss FileCopyPreJDK7 { publicstaticvoid main(String args) { BufferedReader
 in = null; BufferedWriter out = null; try { in = new BufferedReader(new
 FileReader("in.txt")); out = new BufferedWriter(new FileWriter("out.txt"));
 int charRead; while ((charRead = in.read) != -1) { System.out.printf("%c ",
 (char)charRead); out.write(charRead); } } catch (IOException ex) { ex.printStackT
race; } finally { // always close the streamstry { if (in != null) in.close;
 if (out != null) out.close; } catch (IOException ex) { ex.printStackTrace;
 } } try { in.read; // Trigger IOException: Stream closed } catch (IOException
 ex) { ex.printStackTrace; } } }
\end_layout

\begin_layout Standard
jdk7之后
\end_layout

\begin_layout Standard
import java.io.*; // Copy from one file to another file character by character.
 // JDK 7 has a try-with-resources statement, which ensures that // each
 resource opened in try is closed at the end of the statement.publicclass
 FileCopyJDK7 { publicstaticvoid main(String args) { try (BufferedReader
 in = new BufferedReader(new FileReader("in.txt")); BufferedWriter out =
 new BufferedWriter(new FileWriter("out.txt"))) { int charRead; while ((charRead
 = in.read) != -1) { System.out.printf("%c ", (char)charRead); out.write(charRead);
 } } catch (IOException ex) { ex.printStackTrace; } } }
\end_layout

\begin_layout Standard
本教程将Java8的新特新逐一列出，并将使用简单的代码示例来指导你如何使用默认接口方法，lambda表达式，方法引用以及多重Annotation，之后你将会学到
最新的API上的改进，比如流，函数式接口，Map以及全新的日期API
\end_layout

\begin_layout Standard
“Java is still not dead—and people are starting to figure that out.”
\end_layout

\begin_layout Standard
本教程将用带注释的简单代码来描述新特性，你将看不到大片吓人的文字。
\end_layout

\begin_layout Standard
一、接口的默认方法
\end_layout

\begin_layout Standard
Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下：
\end_layout

\begin_layout Standard
interface Formula {
\end_layout

\begin_layout Standard
double calculate(int a);
\end_layout

\begin_layout Standard
default double sqrt(int a) {
\end_layout

\begin_layout Standard
return Math.sqrt(a);
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt
将在子类上可以直接使用。
\end_layout

\begin_layout Standard
Formula formula = new Formula {
\end_layout

\begin_layout Standard
@Override
\end_layout

\begin_layout Standard
public double calculate(int a) {
\end_layout

\begin_layout Standard
return sqrt(a * 100);
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
};
\end_layout

\begin_layout Standard
formula.calculate(100); // 100.0
\end_layout

\begin_layout Standard
formula.sqrt(16); // 4.0
\end_layout

\begin_layout Standard
文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单
的做法。
\end_layout

\begin_layout Standard
译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他
 语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。
 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。
\end_layout

\begin_layout Standard
二、Lambda 表达式
\end_layout

\begin_layout Standard
首先看看在老版本的Java中是如何排列字符串的：
\end_layout

\begin_layout Standard
Listnames = Arrays.asList("peter", "anna", "mike", "xenia");Collections.sort(names
, new Comparator{
\end_layout

\begin_layout Standard
@Override
\end_layout

\begin_layout Standard
public int compare(String a, String b) {
\end_layout

\begin_layout Standard
return b.compareTo(a);
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
});
\end_layout

\begin_layout Standard
只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort
方法。
\end_layout

\begin_layout Standard
在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：
\end_layout

\begin_layout Standard
复制代码 代码如下:
\end_layout

\begin_layout Standard
Collections.sort(names, (String a, String b) -> {
\end_layout

\begin_layout Standard
return b.compareTo(a);
\end_layout

\begin_layout Standard
});
\end_layout

\begin_layout Standard
看到了吧，代码变得更短且更具有可读性，但是实际上还可以写得更短：
\end_layout

\begin_layout Standard
复制代码 代码如下:
\end_layout

\begin_layout Standard
Collections.sort(names, (String a, String b) -> b.compareTo(a));
\end_layout

\begin_layout Standard
对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：
\end_layout

\begin_layout Standard
复制代码 代码如下:
\end_layout

\begin_layout Standard
Collections.sort(names, (a, b) -> b.compareTo(a));
\end_layout

\begin_layout Standard
Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来：
\end_layout

\begin_layout Standard
三、函数式接口
\end_layout

\begin_layout Standard
Lambda 表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的
 接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。
\end_layout

\begin_layout Standard
我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface
 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。
\end_layout

\begin_layout Standard
@FunctionalInterface
\end_layout

\begin_layout Standard
{Converterconverter = (from) -> Integer.valueOf(from);
\end_layout

\begin_layout Standard
Integer converted = converter.convert("123");
\end_layout

\begin_layout Standard
System.out.println(converted); // 123
\end_layout

\begin_layout Standard
需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。
\end_layout

\begin_layout Standard
译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接
收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.e
vents.EventTarget 的addEventListener 第二个参数 EventListener。
\end_layout

\begin_layout Standard
Integer converted = converter.convert("123");
\end_layout

\begin_layout Standard
System.out.println(converted); // 123
\end_layout

\begin_layout Standard
Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：
\end_layout

\begin_layout Standard
复制代码 代码如下:
\end_layout

\begin_layout Standard
converter = something::startsWith;
\end_layout

\begin_layout Standard
String converted = converter.convert("Java");
\end_layout

\begin_layout Standard
System.out.println(converted); // "J"
\end_layout

\begin_layout Standard
接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：
\end_layout

\begin_layout Standard
class Person {
\end_layout

\begin_layout Standard
String firstName;
\end_layout

\begin_layout Standard
String lastName;
\end_layout

\begin_layout Standard
Person {}
\end_layout

\begin_layout Standard
Person(String firstName, String lastName) {
\end_layout

\begin_layout Standard
this.firstName = firstName;
\end_layout

\begin_layout Standard
this.lastName = lastName;
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
接下来我们指定一个用来创建Person对象的对象工厂接口：
\end_layout

\begin_layout Standard
interface PersonFactory
\end_layout

\begin_layout Standard
{
\end_layout

\begin_layout Standard
P create(String firstName, String lastName);
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：
\end_layout

\begin_layout Standard
PersonFactory
\end_layout

\begin_layout Standard
Person person = personFactory.create("Peter", "Parker");
\end_layout

\begin_layout Standard
我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的
构造函数。
\end_layout

\begin_layout Standard
五、Lambda 作用域
\end_layout

\begin_layout Standard
在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。
\end_layout

\begin_layout Standard
六、访问局部变量
\end_layout

\begin_layout Standard
final int num = 1;
\end_layout

\begin_layout Standard
stringConverter =
\end_layout

\begin_layout Standard
(from) -> String.valueOf(from + num);
\end_layout

\begin_layout Standard
stringConverter.convert(2); // 3
\end_layout

\begin_layout Standard
但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：
\end_layout

\begin_layout Standard
int num = 1;
\end_layout

\begin_layout Standard
不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：
\end_layout

\begin_layout Standard
(from) -> String.valueOf(from + num);
\end_layout

\begin_layout Standard
num = 3;
\end_layout

\begin_layout Standard
在lambda表达式中试图修改num同样是不允许的。
\end_layout

\begin_layout Standard
七、访问对象字段与静态变量
\end_layout

\begin_layout Standard
和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：
\end_layout

\begin_layout Standard
class Lambda4 {
\end_layout

\begin_layout Standard
static int outerStaticNum;
\end_layout

\begin_layout Standard
int outerNum; ConverterstringConverter1 = (from) -> {
\end_layout

\begin_layout Standard
outerNum = 23;
\end_layout

\begin_layout Standard
return String.valueOf(from);
\end_layout

\begin_layout Standard
};stringConverter2 = (from) -> {
\end_layout

\begin_layout Standard
outerStaticNum = 72;
\end_layout

\begin_layout Standard
return String.valueOf(from);
\end_layout

\begin_layout Standard
};
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
八、访问接口的默认方法
\end_layout

\begin_layout Standard
还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这
个是不行的。
\end_layout

\begin_layout Standard
Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：
\end_layout

\begin_layout Standard
复制代码 代码如下:
\end_layout

\begin_layout Standard
Formula formula = (a) -> sqrt( a * 100);
\end_layout

\begin_layout Standard
Built-in Functional Interfaces
\end_layout

\begin_layout Standard
JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalI
nterface注解以便能用在lambda上。
\end_layout

\begin_layout Standard
Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是
如何扩展到lambda上使用的。
\end_layout

\begin_layout Standard
Predicate接口
\end_layout

\begin_layout Standard
Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：
\end_layout

\begin_layout Standard
Predicatepredicate = (s) -> s.length > 0;
\end_layout

\begin_layout Standard
predicate.test("foo"); // true
\end_layout

\begin_layout Standard
predicate.negate.test("foo"); // false
\end_layout

\begin_layout Standard
isNotEmpty = isEmpty.negate;
\end_layout

\begin_layout Standard
Function 接口
\end_layout

\begin_layout Standard
Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：
\end_layout

\begin_layout Standard
FunctionbackToString = toInteger.andThen(String::valueOf);
\end_layout

\begin_layout Standard
backToString.apply("123"); // "123"
\end_layout

\begin_layout Standard
Supplier 接口
\end_layout

\begin_layout Standard
Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数
\end_layout

\begin_layout Standard
personSupplier = Person::new;
\end_layout

\begin_layout Standard
personSupplier.get; // new Person
\end_layout

\begin_layout Standard
Consumer 接口
\end_layout

\begin_layout Standard
Consumer 接口表示执行在单个参数上的操作。
\end_layout

\begin_layout Standard
Consumergreeter = (p) -> System.out.println("Hello, " + p.firstName);
\end_layout

\begin_layout Standard
greeter.accept(new Person("Luke", "Skywalker"));
\end_layout

\begin_layout Standard
Comparator 接口
\end_layout

\begin_layout Standard
Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：
\end_layout

\begin_layout Standard
Comparatorcomparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);
\end_layout

\begin_layout Standard
Person p1 = new Person("John", "Doe");
\end_layout

\begin_layout Standard
Person p2 = new Person("Alice", "Wonderland");
\end_layout

\begin_layout Standard
comparator.compare(p1, p2); // > 0
\end_layout

\begin_layout Standard
comparator.reversed.compare(p1, p2); // < 0
\end_layout

\begin_layout Standard
Optional 接口
\end_layout

\begin_layout Standard
Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口
能干什么：
\end_layout

\begin_layout Standard
Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在J
ava 8中，不推荐你返回null而是返回Optional。
\end_layout

\begin_layout Standard
Optionaloptional = Optional.of("bam");
\end_layout

\begin_layout Standard
optional.isPresent; // true
\end_layout

\begin_layout Standard
optional.get; // "bam"
\end_layout

\begin_layout Standard
optional.orElse("fallback"); // "bam"
\end_layout

\begin_layout Standard
optional.ifPresent((s) -> System.out.println(s.charAt(0))); // "b"
\end_layout

\begin_layout Standard
Stream 接口
\end_layout

\begin_layout Standard
java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间
操作返回Stream本身，这样你就可以将多个操作依次串起来。 Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List
或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。
\end_layout

\begin_layout Standard
ListstringCollection = new ArrayList<>;
\end_layout

\begin_layout Standard
stringCollection.add("ddd2");
\end_layout

\begin_layout Standard
stringCollection.add("aaa2");
\end_layout

\begin_layout Standard
stringCollection.add("bbb1");
\end_layout

\begin_layout Standard
stringCollection.add("aaa1");
\end_layout

\begin_layout Standard
stringCollection.add("bbb3");
\end_layout

\begin_layout Standard
stringCollection.add("ccc");
\end_layout

\begin_layout Standard
stringCollection.add("bbb2");
\end_layout

\begin_layout Standard
stringCollection.add("ddd1");
\end_layout

\begin_layout Standard
Java 8扩展了集合类，可以通过 Collection.stream 或者 Collection.parallelStream 来创建一个Stream。下面几节将
详细解释常用的Stream操作：
\end_layout

\begin_layout Standard
Filter 过滤
\end_layout

\begin_layout Standard
过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作 （比如forEach）
。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行 其他Stream操作。
\end_layout

\begin_layout Standard
stringCollection
\end_layout

\begin_layout Standard
.stream
\end_layout

\begin_layout Standard
.filter((s) -> s.startsWith("a"))
\end_layout

\begin_layout Standard
.forEach(System.out::println);
\end_layout

\begin_layout Standard
// "aaa2", "aaa1"
\end_layout

\begin_layout Standard
Sort 排序
\end_layout

\begin_layout Standard
排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。
\end_layout

\begin_layout Standard
stringCollection
\end_layout

\begin_layout Standard
.stream
\end_layout

\begin_layout Standard
.sorted
\end_layout

\begin_layout Standard
.filter((s) -> s.startsWith("a"))
\end_layout

\begin_layout Standard
.forEach(System.out::println);
\end_layout

\begin_layout Standard
// "aaa1", "aaa2"
\end_layout

\begin_layout Standard
需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：
\end_layout

\begin_layout Standard
复制代码 代码如下:
\end_layout

\begin_layout Standard
System.out.println(stringCollection);
\end_layout

\begin_layout Standard
// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1
\end_layout

\begin_layout Standard
Map 映射
\end_layout

\begin_layout Standard
中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类
型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。
\end_layout

\begin_layout Standard
stringCollection
\end_layout

\begin_layout Standard
.stream
\end_layout

\begin_layout Standard
.map(String::toUpperCase)
\end_layout

\begin_layout Standard
.sorted((a, b) -> b.compareTo(a))
\end_layout

\begin_layout Standard
.forEach(System.out::println);
\end_layout

\begin_layout Standard
// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"
\end_layout

\begin_layout Standard
Match 匹配
\end_layout

\begin_layout Standard
Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。
\end_layout

\begin_layout Standard
boolean anyStartsWithA =
\end_layout

\begin_layout Standard
stringCollection
\end_layout

\begin_layout Standard
.stream
\end_layout

\begin_layout Standard
.anyMatch((s) -> s.startsWith("a"));
\end_layout

\begin_layout Standard
System.out.println(anyStartsWithA); // true
\end_layout

\begin_layout Standard
boolean allStartsWithA =
\end_layout

\begin_layout Standard
stringCollection
\end_layout

\begin_layout Standard
.stream
\end_layout

\begin_layout Standard
.allMatch((s) -> s.startsWith("a"));
\end_layout

\begin_layout Standard
System.out.println(allStartsWithA); // false
\end_layout

\begin_layout Standard
boolean noneStartsWithZ =
\end_layout

\begin_layout Standard
stringCollection
\end_layout

\begin_layout Standard
.stream
\end_layout

\begin_layout Standard
.noneMatch((s) -> s.startsWith("z"));
\end_layout

\begin_layout Standard
System.out.println(noneStartsWithZ); // true
\end_layout

\begin_layout Standard
Count 计数
\end_layout

\begin_layout Standard
计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。
\end_layout

\begin_layout Standard
long startsWithB =
\end_layout

\begin_layout Standard
stringCollection
\end_layout

\begin_layout Standard
.stream
\end_layout

\begin_layout Standard
.filter((s) -> s.startsWith("b"))
\end_layout

\begin_layout Standard
.count;
\end_layout

\begin_layout Standard
System.out.println(startsWithB); // 3
\end_layout

\begin_layout Standard
Reduce 规约
\end_layout

\begin_layout Standard
这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：
\end_layout

\begin_layout Standard
Optionalreduced =
\end_layout

\begin_layout Standard
stringCollection
\end_layout

\begin_layout Standard
.stream
\end_layout

\begin_layout Standard
.sorted
\end_layout

\begin_layout Standard
.reduce((s1, s2) -> s1 + "#" + s2);
\end_layout

\begin_layout Standard
reduced.ifPresent(System.out::println);
\end_layout

\begin_layout Standard
// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"
\end_layout

\begin_layout Standard
并行Streams
\end_layout

\begin_layout Standard
前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。
\end_layout

\begin_layout Standard
下面的例子展示了是如何通过并行Stream来提升性能：
\end_layout

\begin_layout Standard
int max = 1000000;
\end_layout

\begin_layout Standard
Listvalues = new ArrayList<>(max);
\end_layout

\begin_layout Standard
for (int i = 0; i < max; i++) {
\end_layout

\begin_layout Standard
UUID uuid = UUID.randomUUID;
\end_layout

\begin_layout Standard
values.add(uuid.toString);
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
然后我们计算一下排序这个Stream要耗时多久，
\end_layout

\begin_layout Standard
串行排序：
\end_layout

\begin_layout Standard
long t0 = System.nanoTime;
\end_layout

\begin_layout Standard
long count = values.stream.sorted.count;
\end_layout

\begin_layout Standard
System.out.println(count);
\end_layout

\begin_layout Standard
long t1 = System.nanoTime;
\end_layout

\begin_layout Standard
long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);
\end_layout

\begin_layout Standard
System.out.println(String.format("sequential sort took: %d ms", millis));
\end_layout

\begin_layout Standard
long count = values.parallelStream.sorted.count;
\end_layout

\begin_layout Standard
System.out.println(count);
\end_layout

\begin_layout Standard
long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);
\end_layout

\begin_layout Standard
System.out.println(String.format("parallel sort took: %d ms", millis));
\end_layout

\begin_layout Standard
// 并行排序耗时: 472 ms
\end_layout

\begin_layout Standard
上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream改为parallelStream。
\end_layout

\begin_layout Standard
Map
\end_layout

\begin_layout Standard
前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。
\end_layout

\begin_layout Standard
Mapmap = new HashMap<>;
\end_layout

\begin_layout Standard
for (int i = 0; i < 10; i++) {
\end_layout

\begin_layout Standard
map.putIfAbsent(i, "val" + i);
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
map.forEach((id, val) -> System.out.println(val));
\end_layout

\begin_layout Standard
以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。
\end_layout

\begin_layout Standard
map.computeIfPresent(3, (num, val) -> val + num);
\end_layout

\begin_layout Standard
map.get(3); // val33
\end_layout

\begin_layout Standard
map.computeIfPresent(9, (num, val) -> null);
\end_layout

\begin_layout Standard
map.containsKey(9); // false
\end_layout

\begin_layout Standard
map.computeIfAbsent(23, num -> "val" + num);
\end_layout

\begin_layout Standard
map.containsKey(23); // true
\end_layout

\begin_layout Standard
map.computeIfAbsent(3, num -> "bam");
\end_layout

\begin_layout Standard
map.get(3); // val33
\end_layout

\begin_layout Standard
接下来展示如何在Map里删除一个键值全都匹配的项：
\end_layout

\begin_layout Standard
map.remove(3, "val3");
\end_layout

\begin_layout Standard
map.get(3); // val33
\end_layout

\begin_layout Standard
map.remove(3, "val33");
\end_layout

\begin_layout Standard
map.get(3); // null
\end_layout

\begin_layout Standard
另外一个有用的方法：
\end_layout

\begin_layout Standard
复制代码 代码如下:
\end_layout

\begin_layout Standard
map.getOrDefault(42, "not found"); // not found
\end_layout

\begin_layout Standard
对Map的元素做合并也变得很容易了：
\end_layout

\begin_layout Standard
map.merge(9, "val9", (value, newValue) -> value.concat(newValue));
\end_layout

\begin_layout Standard
map.get(9); // val9
\end_layout

\begin_layout Standard
map.merge(9, "concat", (value, newValue) -> value.concat(newValue));
\end_layout

\begin_layout Standard
map.get(9); // val9concat
\end_layout

\begin_layout Standard
Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。
\end_layout

\begin_layout Standard
九、Date API
\end_layout

\begin_layout Standard
Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新AP
I里最重要的一些部分：
\end_layout

\begin_layout Standard
Clock 时钟
\end_layout

\begin_layout Standard
Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis 来获取当前的微秒数。某一个特定
的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。
\end_layout

\begin_layout Standard
Clock clock = Clock.systemDefaultZone;
\end_layout

\begin_layout Standard
long millis = clock.millis;
\end_layout

\begin_layout Standard
Instant instant = clock.instant;
\end_layout

\begin_layout Standard
Date legacyDate = Date.from(instant); // legacy java.util.Date
\end_layout

\begin_layout Standard
Timezones 时区
\end_layout

\begin_layout Standard
在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间
转换的时候是极其重要的。
\end_layout

\begin_layout Standard
System.out.println(ZoneId.getAvailableZoneIds);
\end_layout

\begin_layout Standard
// prints all available timezone ids
\end_layout

\begin_layout Standard
ZoneId zone1 = ZoneId.of("Europe/Berlin");
\end_layout

\begin_layout Standard
ZoneId zone2 = ZoneId.of("Brazil/East");
\end_layout

\begin_layout Standard
System.out.println(zone1.getRules);
\end_layout

\begin_layout Standard
System.out.println(zone2.getRules);
\end_layout

\begin_layout Standard
// ZoneRules[currentStandardOffset=+01:00]
\end_layout

\begin_layout Standard
// ZoneRules[currentStandardOffset=-03:00]
\end_layout

\begin_layout Standard
LocalTime 本地时间
\end_layout

\begin_layout Standard
LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以
小时和分钟为单位计算两个时间的时间差：
\end_layout

\begin_layout Standard
LocalTime now1 = LocalTime.now(zone1);
\end_layout

\begin_layout Standard
LocalTime now2 = LocalTime.now(zone2);
\end_layout

\begin_layout Standard
System.out.println(now1.isBefore(now2)); // false
\end_layout

\begin_layout Standard
long hoursBetween = ChronoUnit.HOURS.between(now1, now2);
\end_layout

\begin_layout Standard
long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);
\end_layout

\begin_layout Standard
System.out.println(hoursBetween); // -3
\end_layout

\begin_layout Standard
System.out.println(minutesBetween); // -239
\end_layout

\begin_layout Standard
LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。
\end_layout

\begin_layout Standard
LocalTime late = LocalTime.of(23, 59, 59);
\end_layout

\begin_layout Standard
System.out.println(late); // 23:59:59
\end_layout

\begin_layout Standard
DateTimeFormatter germanFormatter =
\end_layout

\begin_layout Standard
DateTimeFormatter
\end_layout

\begin_layout Standard
.ofLocalizedTime(FormatStyle.SHORT)
\end_layout

\begin_layout Standard
.withLocale(Locale.GERMAN);
\end_layout

\begin_layout Standard
LocalTime leetTime = LocalTime.parse("13:37", germanFormatter);
\end_layout

\begin_layout Standard
System.out.println(leetTime); // 13:37
\end_layout

\begin_layout Standard
LocalDate 本地日期
\end_layout

\begin_layout Standard
LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象
加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。
\end_layout

\begin_layout Standard
LocalDate today = LocalDate.now;
\end_layout

\begin_layout Standard
LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);
\end_layout

\begin_layout Standard
LocalDate yesterday = tomorrow.minusDays(2);
\end_layout

\begin_layout Standard
LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);
\end_layout

\begin_layout Standard
DayOfWeek dayOfWeek = independenceDay.getDayOfWeek;
\end_layout

\begin_layout Standard
System.out.println(dayOfWeek); // FRIDAY
\end_layout

\begin_layout Standard
从字符串解析一个LocalDate类型和解析LocalTime一样简单：
\end_layout

\begin_layout Standard
DateTimeFormatter germanFormatter =
\end_layout

\begin_layout Standard
DateTimeFormatter
\end_layout

\begin_layout Standard
.ofLocalizedDate(FormatStyle.MEDIUM)
\end_layout

\begin_layout Standard
.withLocale(Locale.GERMAN);
\end_layout

\begin_layout Standard
LocalDate xmas = LocalDate.parse("24.12.2014", germanFormatter);
\end_layout

\begin_layout Standard
System.out.println(xmas); // 2014-12-24
\end_layout

\begin_layout Standard
LocalDateTime 本地日期时间
\end_layout

\begin_layout Standard
LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，
都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。
\end_layout

\begin_layout Standard
LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59,
 59);
\end_layout

\begin_layout Standard
DayOfWeek dayOfWeek = sylvester.getDayOfWeek;
\end_layout

\begin_layout Standard
System.out.println(dayOfWeek); // WEDNESDAY
\end_layout

\begin_layout Standard
Month month = sylvester.getMonth;
\end_layout

\begin_layout Standard
System.out.println(month); // DECEMBER
\end_layout

\begin_layout Standard
long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);
\end_layout

\begin_layout Standard
System.out.println(minuteOfDay); // 1439
\end_layout

\begin_layout Standard
只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。
\end_layout

\begin_layout Standard
Instant instant = sylvester
\end_layout

\begin_layout Standard
.atZone(ZoneId.systemDefault)
\end_layout

\begin_layout Standard
.toInstant;
\end_layout

\begin_layout Standard
Date legacyDate = Date.from(instant);
\end_layout

\begin_layout Standard
System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014
\end_layout

\begin_layout Standard
格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：
\end_layout

\begin_layout Standard
DateTimeFormatter formatter =
\end_layout

\begin_layout Standard
DateTimeFormatter
\end_layout

\begin_layout Standard
.ofPattern("MMM dd, yyyy - HH:mm");
\end_layout

\begin_layout Standard
LocalDateTime parsed = LocalDateTime.parse("Nov 03, 2014 - 07:13", formatter);
\end_layout

\begin_layout Standard
String string = formatter.format(parsed);
\end_layout

\begin_layout Standard
System.out.println(string); // Nov 03, 2014 - 07:13
\end_layout

\begin_layout Standard
和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。
\end_layout

\begin_layout Standard
关于时间日期格式的详细信息：http://download.java.net/jdk8/docs/api/java/time/format/DateTimeForm
atter.html
\end_layout

\begin_layout Standard
十、Annotation 注解
\end_layout

\begin_layout Standard
在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。
\end_layout

\begin_layout Standard
首先定义一个包装类Hints注解用来放置一组具体的Hint注解：
\end_layout

\begin_layout Standard
@interface Hints {
\end_layout

\begin_layout Standard
Hint value;
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
@Repeatable(Hints.class)
\end_layout

\begin_layout Standard
@interface Hint {
\end_layout

\begin_layout Standard
String value;
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。
\end_layout

\begin_layout Standard
例 1: 使用包装类当容器来存多个注解（老方法）
\end_layout

\begin_layout Standard
复制代码 代码如下:
\end_layout

\begin_layout Standard
@Hints({@Hint("hint1"), @Hint("hint2")})
\end_layout

\begin_layout Standard
class Person {}
\end_layout

\begin_layout Standard
例 2：使用多重注解（新方法）
\end_layout

\begin_layout Standard
复制代码 代码如下:
\end_layout

\begin_layout Standard
@Hint("hint1")
\end_layout

\begin_layout Standard
@Hint("hint2")
\end_layout

\begin_layout Standard
class Person {}
\end_layout

\begin_layout Standard
第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：
\end_layout

\begin_layout Standard
Hint hint = Person.class.getAnnotation(Hint.class);
\end_layout

\begin_layout Standard
System.out.println(hint); // null
\end_layout

\begin_layout Standard
Hints hints1 = Person.class.getAnnotation(Hints.class);
\end_layout

\begin_layout Standard
System.out.println(hints1.value.length); // 2
\end_layout

\begin_layout Standard
Hint hints2 = Person.class.getAnnotationsByType(Hint.class);
\end_layout

\begin_layout Standard
System.out.println(hints2.length); // 2
\end_layout

\begin_layout Standard
即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方
法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。
\end_layout

\begin_layout Standard
另外Java 8的注解还增加到两种新的target上了：
\end_layout

\begin_layout Standard
复制代码 代码如下:
\end_layout

\begin_layout Standard
@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
\end_layout

\begin_layout Standard
@interface MyAnnotation {}
\end_layout

\begin_layout Standard
关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort,
 StampedLock和CompletableFuture等等。
\end_layout

\end_body
\end_document
